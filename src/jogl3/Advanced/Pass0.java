package jogl3.Advanced;

import com.jogamp.opengl.GL3;
import com.jogamp.opengl.GLAutoDrawable;
//你最后输出的是AxB的贴图
//如果你对高模找UV，然后输出，你输出的是什么？
//你只能对UV找高模，才能输出贴图
public class Pass0 {
	public static void display(GLAutoDrawable Drawable) {
		GL3 gl = Drawable.getGL().getGL3();
		//几何体访问
		//通过PASS0将高模的信息储存在两张纹理中
		//纹理A：尺寸上1000*1000，能够储存1mil个vec3，是点的位置
		//纹理B：尺寸上1000*1000，与纹理A储存顺序相同，储存1mil个vec3，是对应的法线
		//加速结构
		//整个模型在受光照射的时候，可以分成4个部分。对于每一条射线，首先要做的是确定与哪一部分相交，从而在该部分中寻找目标三角形
		//整个模型细分为4份，每一份细分为4瓣，每一瓣细分为4块，每一块细分为4域
		//在找到需要的域后，对域内的三角形进行遍历
		//细分的方法：首先剔除背面，然后计算剩下模型的边界框，将整个框内分为4个方格，每个方格内部再次细分
		//遍历每个三角形，相当于每次3份地遍历所有顶点（步进为3）
		//对一束射线遍历全部三角形，目的并非寻找最近或者寻找相似，而是因为一束射线必然落在三角形的内部，你要找到这个三角形的顶点。
		//可以通过光子到分别任意两点的向量的叉与三角面的法线（硬法线）的比较，来确定是否落在面上
		//加速结构的构建不能在着色器中，因为只需要构建一遍就行了，而不是每次计算都重建一遍
		//在一个FS中放出的射线能够找到4份中的任意一份，因为一个FS对应一个VS，要在FS中找到全部VS，就必须在VS中传入全部顶点
		//
		
	}
	public static void init(GLAutoDrawable Drawable) {
		GL3 gl = Drawable.getGL().getGL3();
		//计算总顶点数量，确定用几张纹理。
		//纹理数量在FS里怎么配置，不算问题。你只是拿两张纹理合并代表一个东西，所以都要遍历，有1就有2
		//暂时先让1024^2mil以上的数字报个错
		//抽取出所有顶点，进行处理
		//我们会需要紧密靠拢紧贴的四个BOX
		//引用顶点buffer
		//遍历顶点buffer
		//注意，你做的不是光追，而是法线烘焙，因此高模的每个角度都会被用到。场景中不存在某个光源方向， 你也无法剔除某个背面，因为不存在背面
		//统计出边界框
		//end
		//遍历顶点buffer
		//问：边界框应该在几个维度上细分？为了效率起见，你应该细分Z轴，也就是说你会得到8个子盒，这样你可以十分简单地跳过代表背面的盒子
		//分成xyz,x-yz,x-y-z,xy-z.....等等8个子盒，每个子盒都是一个新的buffer，只含有一部分的顶点
		//事实上你应该一口气分成64个，也就是循环两个8分法
		//end
		//依次遍历64个盒子，将顶点有组地放在1024*1024贴图中，每个盒子容量128*128（64刚好可以平方，是个矩形）
		//记录64个盒子的边界，然后在GPU中生成64个相同的箱体
		//FS中，首先计算光源会触碰到哪个BOX
		//然后取贴图上对应的区域，对128*128进行遍历
		//所有顶点都是以左上角为中心紧密排列的，填满行再下一行，按行取，连续取到3个0就break，代表已经跑完了

	}
}
