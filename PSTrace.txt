#version 330 core
out vec4 Colors;
in vec2 pos;

float rayMarch(vec3 origin , vec3 direction){
	//256是光线最大迭代次数。不能说是距离，因为每次累加距离都是不确定的，但肯定不是1，所以它类似距离，但不是距离
	float step = 0.0;
	int destination = 0;
	float isin = 100;//答案是否：not in
	for(int i=0;i<10;i++){
		vec3 new_loc = origin + direction * step;//在direction方向上延伸出去的距离，由step决定
		float dist = length(new_loc)  - 1.0;//如果对每个方向上射出的光线算超越多少距离，那么 得到的是一个距离固定但方向多变的曲面，简而言之，是一个origin为中心的球
		if (dist < 0.01) {
			isin = dist;
			break;
		} //光本身是无限制延长的，但我们希望延长到距离R=1的球体的表面差不多地方的时候就结束，所以为了保留当时的步长状态，及时退出
		step = step + dist;//因为dist算的是距离最近的表面还有多少距离，也就是还有多远才能超出1，你按照这个距离走一段路，那要么还没到，要么刚刚到
		destination = i;//我觉得理论上这个循环走两遍就到头了
	}
	//通过dist，能够将场景划分为两类，小于0.01和大于0.01的，也就是在球面上和在球面之外的
	//大于0.01的，得到的结果是小于1的，最小是0
	//小于0.01的，得到的结果近似1
	//场景就这样能够被分为黑和白
	return clamp(1-isin,0,1);
}

void main()
{
	//这是真TM神奇
	//0是全红，-3终于有区分了，但是上下是不分的。应该和ED的配置有关
	vec3 LSOL = vec3(0 , 0 , -3);//Light Source original location，这是一个点，对于平行光无所谓，但对于点光源而言有必要，因为世界围绕点光源中心扭曲包裹，它相当于磁场磁感线的发射者
	vec2 ED = pos;//Emitting direction，正交平行光取垂直屏幕方向 ，即没有X和Y倾斜，对00z标准化；点光源或者透视，则是以LSOL为中心，呈扇形弧形圆形计算屏幕上像素相对于原点LSOL的方向向量，当成射线方向
	//ED的配置可选：仅水平方向的扇形；对XY皆放射状/曲面投影；正交
	//标准化向量受到任意轴的数值影响，某轴上的值=权重，数值越大单位向量就越是“放平”。
	//vec3(pos,z)分析：z值越大，ED越是向前，近乎平行，视角窄；z越小，XY的影响越明显，越是环形
	//pos为0意味：所有光都平行，并且从+Z方向射向-Z
	//z为0意味：在XY平面上呈现均匀的放射状
	//放射的中心是LSOL，你可以说，随着Z值从0到1变化，光线有同一个起点，方向从平面上❀状变成一束立体锥形
	//y为0意味在XY平面上的花形，y为常数，则向量给予一定Y方向的速度，速度并非常数，而是XZ的权重的反比
	vec3 RMD = vec3(ED.x,0,1);//RayMarching Direction；意味向上看的时候，远处的东西不会因为被放的更低（那是y速度并非常数的缘故，想象一些向量，等长，但有一些在Y方向上投影更短，就像旋转了）而可见
	vec4 ED_test_color = vec4((pos+1)/2, 0.0 , 1.0);//输出0~1范围的RG通道，映射在-1~1范围的NDC上
	//pos ranges from -1 to 1, which makes pos+1 ranged from 0 to 2
	//pos可以代表NDC上以中心为00时各像素的相对方向，也就是说，光球被摆在中间，你可以均匀地将光球映射给NDC
	//假设你闭上右眼，而左眼的视角额外广，你看不到右边的大多数东西，却能看到左边的更多。你应该将pos映射到-1.5~0.5
	//----
	//综上所述，你确定了起点和方向
	Colors = vec4(rayMarch(LSOL,RMD),0,0,1);
}